# 设计模式浅谈

### 基础概念SOLID 设计原则

#### 1.SRP（Single Responsibility Principle）单一原则

SRP是SOLID五大设计原则中最容易被误解的一个。也许是名字的原因，很多程序员根据SRP这个名字想当然地认为这个原则就是指：每个模块都应该只做一件事。
没错，后者的确也是一个设计原则，即确保一个函数只完成一个功能。我们在将大型函数重构成小函数时经常会用到这个原则，但这只是一个面向底层实现细节的设计原则，并不是SRP的全部。
SRP描述：任何一个软件模块都应该只对某一类行为者负责。（行为者：一个或多个有共同需求的人）

#### 2.OCP （Open Closed Principle）开闭原则

开闭原则是Bertrand Meyer在1988年提出的，该设计原则认为：设计良好的计算机软件应该易于扩展，同时抗拒修改。换句话说，一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。
软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，将这些相互隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而受到影响。
OCP是我们进行系统架构设计的主导原则，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围。实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。

#### 3.LSP (Liskov Substitution Principle)里氏替换原则

在面向对象这场编程革命兴起的早期，我们的普遍认知是，LSP只不过是指导如何使用继承关系的一种方法，然而随着时间的推移，LSP逐渐演变成了一种更广泛的、指导接口与其实现方式的设计原则。
LSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。

#### 4.ISP (Interface Segregation Principle) 接口隔离原则

在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。从源代码层次来说，这样的依赖关系会导致不必要的重新编译和重新部署，对更高层次的软件架构设计来说，问题也是类似的。

#### 5.DIP (Dependency Inversion Principle)依赖反转原则

依赖反转原则主要想告诉我们的是，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。
LSP如果想要在软件架构设计上追求稳定，就必须使用稳定的抽象接口，少依赖多变的具体实现。在软件架构中，抽象层与具体实现层的边界叫架构边界，它将系统划分为两个部分组件：抽象接口与其具体实现。抽象接口组件中包含了应用的所有高阶业务规则，而具体实现组件中包含了所有这些业务规则所需要做的具体操作及其相关的细节信息。应用程序的控制流跨越架构边界的反向与源代码依赖关系跨越该边界的方向正好相反，源代码依赖方向永远是控制流方向的反转，这就是DIP被称为依赖反转原则的原因。
这个设计原则可以归结为以下几条具体的编码守则：
1、应在代码中使用抽象接口，尽量避免使用那些多变的具体实现类。
2、不要在具体实现类上创建衍生类。
3、不要覆盖（override）包含具体实现的函数，应该设计为抽象函数。
4、应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。

