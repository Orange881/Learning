## 利用decode解决参数过多导致的栈深度问题

将所需参数按规则编码为bytes类型
```
// 模拟参数编码
function abiencode(uint256 a, string memory b, string[2] memory c, uint256[2] memory d) public pure returns(bytes memory) {
         bytes memory result = abi.encode(a,b,c,d);
         return result;
    }
```

decode解码
```
function abidecode(bytes memory data) public pure returns(uint256 a, string memory b, string[2] memory c, uint256[2] memory d ) {
        //解码需要知道编码的参数类型
         (a,b,c,d) = abi.decode(data,(uint256, string, string[2],uint256[2]));

         //剩余逻辑
    }
```

使用汇编解析变量




000000000000000000000000000000000000000000000000000000000000007b  123
00000000000000000000000000000000000000000000000000000000000000a0  160 offset 5
00000000000000000000000000000000000000000000000000000000000000e0  224 offset 7
000000000000000000000000000000000000000000000000000000000000029a  666
0000000000000000000000000000000000000000000000000000000000000378  888
000000000000000000000000000000000000000000000000000000000000000b string 长度 11 
77616e6767756968656e67                                           wangguiheng 
0000000000000000000000000000000000000000000000000000000000000040  64  2
0000000000000000000000000000000000000000000000000000000000000080  128 4
000000000000000000000000000000000000000000000000000000000000000a  10 长度
6269616e206368616e6700000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000006 6 
e69687e5ad970000000000000000000000000000000000000000000000000000
